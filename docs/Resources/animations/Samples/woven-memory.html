<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Woven Memory — Footer Scene</title>
  <style>
    :root { --paper:#F0EEE6; --accent:#3b82f6; --accent2:#93c5fd; }
    html,body { height:100%; margin:0; background: var(--paper); }
    .frame { height:100%; display:grid; place-items:center; }
    canvas { width:min(92vmin,760px); height:min(92vmin,760px); aspect-ratio:1/1; display:block; border-radius:12px; box-shadow: 0 10px 28px rgba(0,0,0,.18); background: var(--paper); }
    .cap { position:fixed; bottom:10px; right:12px; color:#4a453f; opacity:.75; font:12px/1.3 ui-monospace, Menlo, monospace; }
  </style>
</head>
<body>
  <div class="frame"><canvas id="c" width="920" height="920" aria-label="Woven Memory — lines crossing, stories interlaced"></canvas></div>
  <div class="cap">Woven Memory</div>
  <script>
    const canvas=document.getElementById('c'); const ctx=canvas.getContext('2d');
    const BASE_GRID=62, cell=14, cw=cell*0.72, ch=cell; let t=0, animId;
    const col=(n,f)=>getComputedStyle(document.documentElement).getPropertyValue(n).trim()||f;
    function clear(){ const p=col('--paper','#F0EEE6'); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.fillStyle=p; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.font=`${cell}px ui-monospace, Menlo, monospace`; ctx.textAlign='center'; ctx.textBaseline='middle'; }
    function ink(a=1,p=0){ const r1=59,g1=130,b1=246,r2=147,g2=197,b2=253; const r=Math.round(r1+(r2-r1)*p), g=Math.round(g1+(g2-g1)*p), b=Math.round(b1+(b2-b1)*p); ctx.fillStyle=`rgba(${r},${g},${b},${a})`; }
    function draw(time){
      const GRID_SIZE=BASE_GRID; clear(); const cx=canvas.width/2, cy=canvas.height/2; const p=(Math.sin(time*0.5)+1)/2;
      const breath = 0.5 + 0.5*Math.sin(time*0.12);
      const fadeEdge=0.85 + 0.02*breath;
      const thresh = 0.28 + 0.05*(breath-0.5);
      for(let y=0;y<GRID_SIZE;y++) for(let x=0;x<GRID_SIZE;x++){
        const xp=cx+(x-GRID_SIZE/2)*cw, yp=cy+(y-GRID_SIZE/2)*ch;
        const nx=(x-GRID_SIZE/2)/(GRID_SIZE/2), ny=(y-GRID_SIZE/2)/(GRID_SIZE/2);
        const boundary=Math.max(Math.abs(nx),Math.abs(ny)); if(boundary>=fadeEdge) continue; const fade=1-boundary/fadeEdge;
        const d1=Math.sin((x+y)/4 + time*0.9); const d2=Math.cos((x-y)/4 - time*0.7); const v=(d1*0.55+d2*0.45)*fade;
        if(v>thresh){ ink(0.62,p); ctx.fillText('/', xp, yp); }
        else if(v<-thresh){ ink(0.62,p); ctx.fillText('\\', xp, yp); }
        else if(Math.abs(v)<0.08){ ink(0.42,p); ctx.fillText('+', xp, yp); }
      }
    }
    function frame(){ draw(t); t+=0.006; animId=requestAnimationFrame(frame); }
    const reduce=matchMedia('(prefers-reduced-motion: reduce)'); if(!reduce.matches) frame(); else draw(0);
    document.addEventListener('visibilitychange', ()=>{ if(document.hidden){ if(animId) cancelAnimationFrame(animId);} else if(!reduce.matches){ frame(); }});
  </script>
</body>
</html>
