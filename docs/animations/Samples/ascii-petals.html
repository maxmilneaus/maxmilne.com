<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ASCII Petals of Interference</title>
  <style>
    :root { --paper:#F0EEE6; --ink:#333333; --accent:#93c5fd; }
    html,body { height:100%; margin:0; background:var(--paper); }
    .frame { height:100%; display:grid; place-items:center; }
    canvas { width:min(90vmin,720px); height:min(90vmin,720px); aspect-ratio:1/1; display:block; box-shadow: 0 10px 30px rgba(0,0,0,.18); border-radius:12px; background: var(--paper); }
    .cap { position:fixed; bottom:12px; right:14px; color:#4a453f; opacity:.65; font:12px/1.3 ui-monospace, Menlo, monospace; }
  </style>
</head>
<body>
  <div class="frame">
    <canvas id="ascii" width="840" height="840" aria-label="ASCII petal-like pattern formed by wave interference"></canvas>
  </div>
  <div class="cap">ASCII Petals â€” harmony of opposites</div>
  <script>
    const canvas = document.getElementById('ascii');
    const ctx = canvas.getContext('2d');
    const GRID_SIZE = 64;
    const cell = 13; const cw = cell*0.72; const ch = cell;
    const CHARS = ['/', '\\', '|'];
    let t = 0; ctx.textAlign='center'; ctx.textBaseline='middle';

    let animId;
    function drawOnce(time){
      const tLocal = time ?? t;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // background paper
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--paper') || '#F0EEE6';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.font = `${cell}px ui-monospace, Menlo, monospace`;
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--ink') || '#333333';

      const cx = canvas.width/2, cy = canvas.height/2;
      for(let y=0;y<GRID_SIZE;y++){
        for(let x=0;x<GRID_SIZE;x++){
          const w1 = Math.sin((x+y)/4 + tLocal);
          const w2 = Math.cos((x-y)/4 - tLocal*0.7);
          const bx = Math.abs(x-GRID_SIZE/2)/(GRID_SIZE/2);
          const by = Math.abs(y-GRID_SIZE/2)/(GRID_SIZE/2);
          const boundary = Math.max(bx,by);
          if(boundary < 0.86){
            const combined = w1*0.6 + w2*0.4;
            const fade = 1 - (boundary/0.86);
            const v = combined * fade;
            let char = ' ';
            if(v > 0.28) char = CHARS[0];
            else if(v < -0.28) char = CHARS[1];
            else if(Math.abs(v) < 0.1) char = CHARS[2];
            if(char !== ' '){
              const xp = cx + (x-GRID_SIZE/2)*cw;
              const yp = cy + (y-GRID_SIZE/2)*ch;
              ctx.fillText(char,xp,yp);
            }
          }
        }
      }
    }
    function frame(){
      drawOnce(t);
      t += 0.0075; animId = requestAnimationFrame(frame);
    }
    const reduce = matchMedia('(prefers-reduced-motion: reduce)');
    if (!reduce.matches) { frame(); } else { drawOnce(0); }
    reduce.addEventListener('change', (e)=>{
      if (e.matches && animId) { cancelAnimationFrame(animId); drawOnce(0); }
      else if (!e.matches) frame();
    });
  </script>
</body>
</html>
