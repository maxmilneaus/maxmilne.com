<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Continuity Draft Animations</title>
  <style>
    :root {
      --paper: #f4f1ea;
      --ink: #322c22;
      --accent-a: #6b8f71;
      --accent-b: #c4835e;
      --accent-c: #4f5a63;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: var(--paper);
      color: var(--ink);
      font: 16px/1.55 "IBM Plex Sans", "Segoe UI", system-ui, sans-serif;
      letter-spacing: 0.01em;
      display: flex;
      justify-content: center;
      padding: 32px;
      transition: background 1.2s ease;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(circle at calc(var(--pointer-x, 0.5) * 100%) calc(var(--pointer-y, 0.5) * 100%), rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0) 48%);
      opacity: 0.35;
      transition: opacity 0.8s ease;
      mix-blend-mode: screen;
      z-index: 0;
    }
    body.pointer-active::before {
      opacity: 0.55;
    }
    main {
      width: min(960px, 94vw);
      display: flex;
      flex-direction: column;
      gap: 48px;
      position: relative;
      z-index: 1;
    }
    header.intro {
      background: rgba(255, 255, 255, 0.6);
      border: 1px solid rgba(50, 44, 34, 0.08);
      border-radius: 20px;
      padding: 28px 32px;
      box-shadow: 0 30px 60px rgba(26, 18, 9, 0.06);
      opacity: 0;
      transform: translateY(24px);
      animation: introReveal 1.4s cubic-bezier(0.22, 0.61, 0.36, 1) 0.2s forwards;
    }
    header.intro h1 {
      margin: 0 0 12px;
      font-size: clamp(24px, 3vw, 34px);
    }
    header.intro p {
      margin: 0;
      max-width: 58ch;
    }
    section.draft {
      padding: 28px;
      background: rgba(255, 255, 255, 0.52);
      border: 1px solid rgba(50, 44, 34, 0.08);
      border-radius: 20px;
      box-shadow: 0 24px 55px rgba(26, 18, 9, 0.07);
      display: flex;
      flex-direction: column;
      gap: 18px;
      opacity: 0;
      transform: translateY(42px);
      filter: saturate(0.9) brightness(0.97);
      transition: opacity 0.9s ease, transform 0.9s cubic-bezier(0.24, 0.8, 0.32, 1), filter 1s ease;
    }
    section.draft.is-visible {
      opacity: 1;
      transform: translateY(0);
      filter: saturate(1) brightness(1);
    }
    section.draft h2 {
      margin: 0;
      font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size: clamp(18px, 2.5vw, 22px);
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    section.draft p {
      margin: 0;
      max-width: 64ch;
      color: rgba(50, 44, 34, 0.82);
    }
    canvas {
      width: 100%;
      height: auto;
      aspect-ratio: 4 / 3;
      border-radius: 16px;
      background: var(--paper);
      box-shadow: inset 0 0 0 1px rgba(50, 44, 34, 0.05);
      transition: box-shadow 1s ease, filter 1s ease;
    }
    section.draft.is-visible canvas {
      box-shadow: inset 0 0 0 1px rgba(50, 44, 34, 0.05), 0 18px 48px rgba(26, 18, 9, 0.06);
      filter: saturate(1.03);
    }
    @keyframes introReveal {
      from { opacity: 0; transform: translateY(24px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (max-width: 720px) {
      body { padding: 22px; }
      section.draft { padding: 22px; }
    }
  </style>
</head>
<body>
  <main>
    <header class="intro">
      <h1>Continuity Draft Animations</h1>
      <p>Five quiet studies exploring the weave between usefulness, care, and slow transformation. Each draft nods to the About page passage, folds in Way of Code style pacing, and borrows the gentle, hand-crafted spirit of the ASCII Petals experiments.</p>
    </header>

    <section class="draft">
      <h2>Draft 1 · Stone Capsule</h2>
      <p>A single rounded capsule sits in quiet balance. Its body subtly breathes and catches light as if smoothed by years of touch.</p>
      <canvas width="720" height="540" data-draft="steps" aria-label="Minimal capsule form with slow highlight and breathing ratio"></canvas>
    </section>

    <section class="draft">
      <h2>Draft 2 · Breathing Stroke</h2>
      <p>One hairline stroke drifts between two anchors. Ghost strokes trail behind, a memory of movement rather than motion itself.</p>
      <canvas width="720" height="540" data-draft="flow" aria-label="Minimal calligraphic line with subtle ghost trails"></canvas>
    </section>

    <section class="draft">
      <h2>Draft 3 · Lattice Whisper</h2>
      <p>A sparse grid murmurs: dashes phase in and out while a soft diagonal glint wanders across the field.</p>
      <canvas width="720" height="540" data-draft="weave" aria-label="Sparse dashed grid with drifting diagonal glint"></canvas>
    </section>

    <section class="draft">
      <h2>Draft 4 · Coalescence</h2>
      <p>Few firefly points drift and slowly agree on a centre. Glow accumulates where attention rests.</p>
      <canvas width="720" height="540" data-draft="emergent" aria-label="Few glowing points softly coalescing toward centre"></canvas>
    </section>

    <section class="draft">
      <h2>Draft 5 · Horizon Pulse</h2>
      <p>A gentle horizon carries a long, slow wave. A seed-circle above breathes with it.</p>
      <canvas width="720" height="540" data-draft="bloom" aria-label="Minimal horizon line with slow wave and breathing seed"></canvas>
    </section>
  </main>

  <script>
    const pointer = { x: 0.5, y: 0.5, active: false };
    let pointerFadeTimer = null;

    function updatePointerVars() {
      document.documentElement.style.setProperty('--pointer-x', pointer.x.toFixed(3));
      document.documentElement.style.setProperty('--pointer-y', pointer.y.toFixed(3));
    }

    document.addEventListener('pointermove', (event) => {
      pointer.x = event.clientX / window.innerWidth;
      pointer.y = event.clientY / window.innerHeight;
      pointer.active = true;
      updatePointerVars();
      document.body.classList.add('pointer-active');
      if (pointerFadeTimer) clearTimeout(pointerFadeTimer);
      pointerFadeTimer = setTimeout(() => {
        document.body.classList.remove('pointer-active');
      }, 1800);
    });

    document.addEventListener('pointerleave', () => {
      pointer.active = false;
      if (pointerFadeTimer) clearTimeout(pointerFadeTimer);
      document.body.classList.remove('pointer-active');
    });

    updatePointerVars();

    const TAU = Math.PI * 2;

    function roundedRect(ctx, x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + w - radius, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
      ctx.lineTo(x + w, y + h - radius);
      ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
      ctx.lineTo(x + radius, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    const draftFns = {
      steps(state, t) {
        // Stone Capsule — one distilled object with breathing proportions and a gentle highlight
        const { ctx, canvas } = state;
        const { width, height } = canvas;
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#f4f1ea';
        ctx.fillRect(0, 0, width, height);

        const cx = width / 2;
        const cy = height / 2;
        const w = width * (0.58 + Math.sin(t * 0.12) * 0.02);
        const h = height * (0.18 + Math.sin(t * 0.2 + 1.3) * 0.015);
        const r = Math.min(h / 2, 32 + 12 * Math.sin(t * 0.16));
        const x = cx - w / 2;
        const y = cy - h / 2;

        // Base body
        ctx.fillStyle = '#eae5dc';
        roundedRect(ctx, x, y, w, h, r);
        ctx.fill();

        // Edge shading for tactility
        ctx.strokeStyle = 'rgba(50,44,34,0.12)';
        ctx.lineWidth = 2;
        roundedRect(ctx, x, y, w, h, r);
        ctx.stroke();

        // Soft highlight that gently tracks pointer
        const px = pointer.active ? pointer.x : 0.5;
        const py = pointer.active ? pointer.y : 0.5;
        const hlx = lerp(x + w * 0.25, x + w * 0.75, px);
        const hly = lerp(y + h * 0.35, y + h * 0.65, py);
        const grad = ctx.createRadialGradient(hlx, hly, 4, hlx, hly, Math.max(w, h) * 0.6);
        grad.addColorStop(0, 'rgba(255,255,255,0.18)');
        grad.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = grad;
        roundedRect(ctx, x, y, w, h, r);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';

        // A faint medial polish, fixed to the object
        const polish = ctx.createLinearGradient(x, cy, x + w, cy);
        polish.addColorStop(0.45, 'rgba(255,255,255,0)');
        polish.addColorStop(0.5, 'rgba(255,255,255,0.10)');
        polish.addColorStop(0.55, 'rgba(255,255,255,0)');
        ctx.fillStyle = polish;
        roundedRect(ctx, x, y, w, h, r);
        ctx.fill();
      },

      flow(state, t) {
        // Breathing Stroke — one airy, calligraphic curve with ghost trails
        const { ctx, canvas } = state;
        const { width, height } = canvas;
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#f4f1ea';
        ctx.fillRect(0, 0, width, height);

        const margin = 48;
        const mid = height * 0.52;
        const amp = height * (0.08 + (pointer.active ? pointer.y * 0.05 : 0));
        const phase = t * 0.35;
        const spread = 0.12;

        ctx.lineCap = 'round';
        ctx.shadowColor = 'rgba(50,44,34,0.25)';
        ctx.shadowBlur = 10;

        for (let k = 0; k < 3; k++) {
          const o = (k - 1) * spread;
          ctx.beginPath();
          const y0 = mid + Math.sin(phase + o) * amp * 0.2;
          const y1 = mid - Math.sin(phase * 0.9 - o) * amp * 0.1;
          const y2 = mid + Math.sin(phase * 1.1 + o) * amp * 0.2;
          const y3 = mid + Math.sin(phase + o) * amp * 0.25;
          ctx.moveTo(margin, y0);
          ctx.bezierCurveTo(width * 0.36, y1, width * 0.64, y2, width - margin, y3);
          ctx.strokeStyle = `rgba(50,44,34,${0.36 - k * 0.14})`;
          ctx.lineWidth = 1.8 - k * 0.4;
          ctx.stroke();
        }

        ctx.shadowBlur = 0;
      },

      weave(state, t) {
        // Lattice Whisper — sparse dashed grid with a drifting diagonal glint
        const { ctx, canvas, cache } = state;
        const { width, height } = canvas;
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#f4f1ea';
        ctx.fillRect(0, 0, width, height);

        if (!cache.layout) {
          cache.cols = 8;
          cache.rows = 5;
          cache.margin = 64;
          cache.layout = true;
        }

        const { cols, rows, margin } = cache;
        const usableW = width - margin * 2;
        const usableH = height - margin * 2;

        ctx.setLineDash([3, 14]);
        ctx.lineDashOffset = -t * 24;
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(50,44,34,0.22)';
        ctx.lineCap = 'round';

        // Vertical lines
        for (let c = 0; c < cols; c++) {
          const x = margin + (usableW * c) / (cols - 1);
          ctx.beginPath();
          ctx.moveTo(x, margin);
          ctx.lineTo(x, height - margin);
          ctx.stroke();
        }
        // Horizontal lines
        for (let r = 0; r < rows; r++) {
          const y = margin + (usableH * r) / (rows - 1);
          ctx.beginPath();
          ctx.moveTo(margin, y);
          ctx.lineTo(width - margin, y);
          ctx.stroke();
        }

        // Soft diagonal glint sweeping across
        const diag = (Math.sin(t * 0.35) + 1) / 2; // 0..1
        const diagX = lerp(margin - usableH, width - margin, diag);
        const grad = ctx.createLinearGradient(diagX - 80, margin, diagX + 80, height - margin);
        grad.addColorStop(0, 'rgba(107,143,113,0)');
        grad.addColorStop(0.5, 'rgba(107,143,113,0.18)');
        grad.addColorStop(1, 'rgba(107,143,113,0)');

        ctx.setLineDash([]);
        ctx.lineWidth = 2;
        ctx.strokeStyle = grad;
        ctx.beginPath();
        ctx.moveTo(margin, margin);
        ctx.lineTo(width - margin, height - margin);
        ctx.stroke();
      },

      emergent(state, t) {
        // Coalescence — few glowing points drift and slowly agree on a centre
        const { ctx, canvas, cache } = state;
        const { width, height } = canvas;
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#f4f1ea';
        ctx.fillRect(0, 0, width, height);

        if (!cache.points) {
          const count = 38;
          cache.points = Array.from({ length: count }, (_, i) => ({
            angle: Math.random() * TAU,
            radius: 0.35 + Math.random() * 0.6,
            speed: 0.1 + Math.random() * 0.2,
          }));
        }

        const { points } = cache;
        const cx = width / 2;
        const cy = height / 2;
        const scale = Math.min(width, height) * 0.42;
        const agree = (Math.sin(t * 0.12) + 1) / 2; // 0..1

        ctx.globalCompositeOperation = 'lighter';
        ctx.shadowColor = 'rgba(107,143,113,0.4)';
        ctx.shadowBlur = 18;

        for (const p of points) {
          const wobble = Math.sin(t * p.speed + p.angle * 3) * 0.02;
          const r = lerp(p.radius, 0.18, agree) + wobble;
          const ang = p.angle + t * 0.05;
          const x = cx + Math.cos(ang) * r * scale;
          const y = cy + Math.sin(ang) * r * scale;
          const alpha = 0.07 + (1 - r) * 0.2;
          ctx.beginPath();
          ctx.fillStyle = `rgba(50,44,34,${alpha})`;
          ctx.arc(x, y, 3.2, 0, TAU);
          ctx.fill();
        }

        ctx.globalCompositeOperation = 'source-over';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.fillStyle = 'rgba(196,131,78,0.22)';
        ctx.arc(cx, cy, scale * 0.16, 0, TAU);
        ctx.fill();
      },

      bloom(state, t) {
        // Horizon Pulse — a slow horizon wave and a breathing seed-circle
        const { ctx, canvas } = state;
        const { width, height } = canvas;
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = '#f4f1ea';
        ctx.fillRect(0, 0, width, height);

        const horizonY = height * 0.64;
        const amp = height * 0.02;
        const speed = 0.18;

        // Horizon wave
        ctx.beginPath();
        ctx.moveTo(0, horizonY);
        for (let x = 0; x <= width; x += 6) {
          const y = horizonY + Math.sin((x / width) * TAU + t * speed) * amp;
          ctx.lineTo(x, y);
        }
        ctx.strokeStyle = 'rgba(50,44,34,0.28)';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Seed-circle breathing above horizon
        const cx = width * 0.5;
        const baseR = Math.min(width, height) * 0.06;
        const breath = 1 + Math.sin(t * 0.22) * 0.06;
        const cy = horizonY - baseR * 1.4;

        const rg = ctx.createRadialGradient(cx, cy, baseR * 0.1, cx, cy, baseR * 1.6 * breath);
        rg.addColorStop(0, 'rgba(196,131,78,0.22)');
        rg.addColorStop(1, 'rgba(196,131,78,0)');
        ctx.fillStyle = rg;
        ctx.beginPath();
        ctx.arc(cx, cy, baseR * 1.4 * breath, 0, TAU);
        ctx.fill();

        ctx.beginPath();
        ctx.fillStyle = '#f4f1ea';
        ctx.arc(cx, cy, baseR * 0.6, 0, TAU);
        ctx.fill();
      },
    };

    const reduce = matchMedia('(prefers-reduced-motion: reduce)');

    function setupDraft(canvas) {
      const key = canvas.dataset.draft;
      const fn = draftFns[key];
      if (!fn) return;
      const ctx = canvas.getContext('2d');
      const state = { ctx, canvas, cache: {} };
      let frameId = null;

      const loop = (time) => {
        fn(state, time / 1000);
        frameId = requestAnimationFrame(loop);
      };

      if (reduce.matches) {
        fn(state, 0);
      } else {
        frameId = requestAnimationFrame(loop);
      }

      reduce.addEventListener('change', (event) => {
        if (event.matches) {
          if (frameId) cancelAnimationFrame(frameId);
          frameId = null;
          fn(state, 0);
        } else {
          if (!frameId) frameId = requestAnimationFrame(loop);
        }
      });
    }

    document.querySelectorAll('canvas[data-draft]').forEach(setupDraft);

    const sections = document.querySelectorAll('section.draft');
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        entry.target.classList.toggle('is-visible', entry.isIntersecting);
      });
    }, { threshold: 0.35, rootMargin: '0px 0px -10%' });

    sections.forEach((section) => observer.observe(section));
  </script>
</body>
</html>
